<html>
  <head>
    <style>
    </style>
    <script>
      // find common elements in two sorted arrays
      (function(){
        let arr1 = [1, 4, 9, 11, 19];
        let arr2 = [2, 3, 4, 5, 6, 7, 8, 11, 12, 13, 14, 19];
        const result = [];
        for (let i = arr1[0], j = arr2[0]; i < arr1.length && j < arr2.length;) {
          if (arr1[i] < arr2[j]) {
            i++;
          } else if (arr1[i] > arr2[j]) {
            j++;
          } else {
            result.push(arr1[i]);
            i++;
            j++;
          }
        }
        console.log(result);
      })();

      /*
        VmWare
        1. two arrays sorted, find common elements
        2. i/p: 121  o/p: 11 12 11, i/p: 1121  o/p: 21 12 11   count/number only if it's consecutive
        3. debounce - do not have backend call for a span of 400ms -- type abc (within 400ms) only one call, there has to be a gap of 400ms between current type and previous for call to BE
        4. copy object to other object - without using _.clone
        5. nested views, controllers - a page, common left pane, you should load different views on the right (ui-router, state based routing)
        6. find duplicates in an arrays, and keep it in another array. I/p: [a,b,c,d,c,a]  o/p: [a,c]

        Amazon:
        1.anagram
        2.process between what happens when you type in the URL and content loads
        3. http
        4. 1123 - one thousand one hundred twenty three
        5. Pascal triangle


       1. balance parenthesis ’{[])}’ — false
       2. [1,1,1,2,2]  - number which occurs even number of times
       3. challenging work recent
       4. give an example where u disagree with other solution and how do u handle to convince u r right.
       5. example where u suggested customer with a better approach and how did u convince him.
       6. file upload (css, html, js) - click on select, u can choose file and drag and drop the file. Selected file show down.
       7. tough time with a project.
       8. ex where u r stuck on input from someone and how do u get that.
       9. why polymer.js - whose decision?
       10. write code to develop chess in react.js (routing, what happens on login button click)


        accordion

        FACEBOOK - http://codereview.stackexchange.com/questions/86334/given-a-sequence-of-positive-integers-a-and-an-integer-t-return-true-if-a-conti

        MICROSOFT
        1. write code to find first duplicate element in the array if all the elements are smaller than the array size
        2. Given infinite stream of integers, find kth largest element at any point of time

      Service Now
     //*** find union and intersection of two sorted arrays (https://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/)

      Amazon:
      1)
      var input = [
        {
          custId: 123,
          producs: [id1, id2, id5]
        },
        {
          custId: 124,
          producs: [id2]
        },
        {
          custId: 125,
          producs: [id2, id3, id4, id5, id6]
        },
        {
          custId: 126,
          producs: [id2, id4, id5]
        }
      ];

      //Get top 3 purchased items of all customers - id2 (4 times), id5 (3 times), id4 (2 times)

      const map = {};
     for (let cust of input) {
         for (let item of cust.producs) {
             if(map.hasOwnProperty(item)) {
                map[item]++;
             } else {
                 map[item] = 1;
             }
         }
     }
     map -> {id1: 1, id2: 2, id3: 1, id4: 2, id5: 3, id6: 1}
     now to get top 3 purchased items, construct a max heap and do 3 pop operations
     or construct a min heap of size 3 with the first three items, and if new item value is less than or equal to root (min value in the tree), ignore.
     If it's greater than root, then pop root and heapify with newly inserted value.

      2)
      Move a circle from one point to right



      GE Digital:
       http://jsfiddle.net/r5TeS/12/
       tab_efficient.html -- design tabs

      Paypal: progress bar, async wait promise, convert callback to promise, bingo game (https://github.com/noahpen/bingo-js)

       general algorithmic: recursion, graph theory (trees), backtracking, linkedlist, stack, queue, dynamic programming.

      Atlassian: panagram, balanced paranthesis
      */

     // apple -  persist selection of checkbox from the URL as in when you reload state should persist, TTFB (time to first bye), how to increase performance of the site, client side vs server side rendering
    // glassdoor - 1) top left, top right, bottom left, bottom right - four divs to be positioned accordingly. Mobile responsive stacked one over other. (media queries)
      // 2) big string - I want freq of all words and retrieve top 5 words.

      // singalfx - find unique elements in an array

      //8X8
      // i/p: “ab  cde   fghi     j” 20   // 2 3 5
      // o/p: "ab    cde   fghi   j" 20   // 4 3 3
      // redistribute spaces in the output evenly with left focus, so both i/p and o/p are of same length (so cannot be 3 4 3 or 3 3 4).

      // alation: next greater element in an array i/p: [5, 3, 9, 7, 2, 3] o/p: [9, 9, -1, -1, 3, -1]

      (function() {
        function parseStr(str) {
          const parts = str.split(" ");
          let result = [];
          let resultStr = '';
          for (let part of parts) {
            if (part.length > 0) {
              // if it's a space, ignore
              result.push(part);
            }
          }
          const numberOfSpaces = str.length - result.join("").length; // 10
          const slots = result.length - 1; // 3
          const share = Math.floor(numberOfSpaces/slots); // 3
          let balance = numberOfSpaces % slots; // numberOfSpaces - (slots * share);
          for (let i = 0; i < slots; i++) {
            if (balance <= 0) {
              break;
            }
            result[i]  = result[i] + ' ';
            balance--;
          }
          let joinStr = ' '.repeat(share);
          resultStr = result.join(joinStr);
          return resultStr;
          // [ab, cde, fghi, j];
        }

        const res = parseStr('ab  cde   fghi     j');
      })();

      //skytap

      //
      // NEW QUESTION
      //

      // Fix the following code so that the counter increments
      // appropriately while keeping the setTimeout and for
      // loop intact.

      // function createTimeoutLoop() {
      //   var i = 0;

      //   for (i = 0; i < 3 ; i++) {
      //     setTimeout(function() {
      //       console.log('The value is: ' + i);
      //     }, 500);
      //   }
      // }

      // call the function, which should print 0, 1, 2 to the console.
      // createTimeoutLoop();

      /////// SOLUTION - create a closure for each loop iteration so context of i is maintained within the setTimeout separately
      function createTimeoutLoop() {
        var i = 0;
        for (i = 0; i < 3; i++) {
          (function(i){
            setTimeout(function() {
              console.log('The value is: ' + i);
            }, 500);
          })(i);
        }
      }
      createTimeoutLoop();
      //
      // NEW QUESTION
      //

      // Create a Person object with 2 methods, "setName" and "printName"
      // that can be chained so that the code below can be run successfully.

      //////////////////////////////
      // ENTER YOUR SOLUTION HERE //
      //////////////////////////////
      class Person {
        constructor(name) {
          this.name = name;
        }
        printName() {
          console.log(` ${this.name} `);
          return this;
        }
        setName(name) {
          this.name = name;
          return this;
        }
      }

      // Uncomment this code when you are ready:
      var person = new Person("Jill");
      person.printName().setName("Tom").printName();
      // This should output "Jill" and then "Tom" in the console.

      //
      // NEW QUESTION
      //

      // Imagine you have a button and you want to ensure the click handler
      // is not fired more than once in a short period of time.
      // Write a function that only allows the logMessage function to be fired
      // after handleClick has not been called for 1000ms.

      // Uncomment this code when you are ready:
      const logMessage = (event) => { console.log('Function fired!') }
      const callOnceAfter = (fn, time) => {
        // debounce logic
        let handle;
        return function() {
          if (handle) {
            clearTimeout(handle)
          }
          handle = setTimeout(fn, time);
        }
      }

      const handleClick = callOnceAfter(logMessage, 1000)
      handleClick();
      handleClick();
      handleClick();
      handleClick();

      // After 1000 ms has elapsed since the last call
      // "Function fired!" should be printed to the console

      // 8x8
      /*
      event.preventDefault - to stop tab from going to background from modal popup(on focus out of input field of modal, do e.preventdefault)
      (ref for above - https://stackoverflow.com/questions/1314450/jquery-how-to-capture-the-tab-keypress-within-a-textbox)
      why 0.1+0.2 !== 0.3
      why below does not return object (automatic semicolon insertion by JS engine)
      return
      {
      ...
      }
      reverse linkedlist
      getMin() operation on stack in O(1) time complexity. you can use auxiliary DS. -> maintain one more min stack for every element of the stack
      CSS grid layout **
       */

      //informatica - object equality with nested objects, arrays, func how to test
      //informatica

      (function(){
        class NumberCollection {
          constructor(){
            // initialize any internal variables for NumberCollection class
            this.elementColMap = {};
            this.min = Number.MAX_SAFE_INTEGER;
            this.max = Number.MIN_SAFE_INTEGER;
          }
          /**
           * Adds the element into the NumberCollection. Duplicates will be ignored.
           */
          addElement (element) {
            if (!Object.hasOwnProperty(element)) {
              this.elementColMap[element] = element;
              if (element < this.min) {
                this.min = element;
              }
              if (element > this.max) {
                this.max = element;
              }
            }
          }

          /**
           * Manipulates this NumberCollection so that it becomes the union between
           * itself and input NumberCollection. The resulting this NumberCollection
           * should contain unique numbers.
           */
          union (input){
            //input.elementColMap = {2: 2, 3: 3, 6: 6, 8: 8};
            for(const key in input.elementColMap) {
              this.elementColMap[key] = key;
            }
          }

          /**
           * Returns a new NumberCollection contains elements that fall into the
           * overlapping range between this NumberCollection and input
           * NumberCollection, inclusive.
           **/
          rangeOverlap(input) {
            const rangeMin = Math.max(this.min, input.min);
            const rangeMax = Math.min(this.max, input.max);
            const newCol = new NumberCollection();
            for (const key in this.elementColMap) {
              if (key >= rangeMin && key <= rangeMax) {
                newCol.addElement(key);
              }
            }
            for (const key in input.elementColMap) {
              if (key >= rangeMin && key <= rangeMax) {
                newCol.addElement(key);
              }
            }
            return newCol;
          }
        }
        //-------------------------------------------
        //Union:
        let NC1 = new NumberCollection();
        NC1.addElement(1);
        NC1.addElement(3);
        NC1.addElement(7);
        console.log('NC1 ', JSON.stringify(NC1));

        let NC2 = new NumberCollection();
        NC2.addElement(2);
        NC2.addElement(3);
        NC2.addElement(6);
        NC2.addElement(8);
        console.log('NC2 ', JSON.stringify(NC2));

        NC1.union(NC2); // results in NC1 having elements {1,2,3,7,6,8} (in any order)
        console.log('UNION ', JSON.stringify(NC1));
        //-----------------------------

        let NC3 = new NumberCollection();
        NC3.addElement(1);
        NC3.addElement(3);
        NC3.addElement(7);
        NC3.addElement(12);

        let NC4 = new NumberCollection();
        NC4.addElement(2);
        NC4.addElement(8);
        NC4.addElement(6);
        NC4.addElement(9);
        let NC5 = NC3.rangeOverlap(NC4); // NC3 has elements {2, 3, 6, 7, 8, 9} (in any order)
        // the elements of NC1 and NC2 could be added in any order and the output, NC3, would not change
        console.log('rangeover1', JSON.stringify(NC5.elementColMap));
        //----------------------------
        let NC6 = new NumberCollection();
        NC6.addElement(4);
        NC6.addElement(5);
        NC6.addElement(9);
        NC6.addElement(12);

        let NC7 = new NumberCollection();
        NC7.addElement(3);
        NC7.addElement(5);
        NC7.addElement(6);
        NC7.addElement(10);
        NC7.addElement(11);

        let NC8 = NC6.rangeOverlap(NC7); // NC3 has elements {4, 5, 6, 9, 10, 11} (in any order)
        console.log('rangeover2', JSON.stringify(NC8.elementColMap));
      })();

      /*
      SQUARE
       */
      (function(){
        const queryString = 'key1=value1&key2=value2';
        const queryString2 = 'key1=value1&key2=value2&key3[]=value3a&key3[]=value3b';

        /*

        const qs =  {
          key1: 'value1',
          key2: 'value2',
          key3: ['value3a', 'value3b']
        }

        */

        const res = getKeyValMap(queryString2);
        console.log(res);

        function getKeyValMap(str) {
          const pairMap = {};
          const keyValPairs = str.split("&"); // ['key=value1', 'key=value2',..]
          for (const pair of keyValPairs) {
            const parts = pair.split("=");  // ['key', 'value1']
            const key = parts[0];
            const val = parts[1];
            addKeyValue(pairMap, key, val);
          }
          return pairMap;
        }

        // addKeyValue(map, key, value) -> map
        // addKeyValue(myMap, 'key5[]', 'newValue')
        function addKeyValue(map, key, value) {
          const newMap = JSON.parse(JSON.stringify(map));
          if (key.indexOf('[]') !== -1) {
            const myKey = key.replace('[]','');
            if (myKey in map) {
              map[myKey].push(value);
            } else {
              map[myKey] = [value];
            }
          } else {
            map[key] = value;
          }
          return map;
        }

        console.log('----', addKeyValue({}, 'key5[]', 'newValue'));

        /*
        input:
        { key1: 'value1',
          key2: 'value2',
          key3: [ 'value3a', 'value3b' ]
        }
        output: 'key1=value1&key2=value2&key3[]=value3a&key3[]=value3b'
        */
        // toQueryString(map) -> string
        function toQueryString(map) {
          let result = [];
          for (const key in map) {
            const val = map[key]; //[]
            if (Array.isArray(val)) {
              for (const elem of val) {
                result.push(`${key}[]=${elem}`);
              }
            } else {
              result.push(`${key}=${val}`);
            }

          }
          // ['key1=value1', 'key2=value2', 'key3=[..]')];
          return result.join('&');
        }

        console.log(toQueryString({ key1: 'value1',
          key2: 'value2',
          key3: [ 'value3a', 'value3b' ]
        }));

      })();

      //Chronicle - Google X company

      /**
       * Create a key-value map
       * Expected behavior example:
       *
       * 12:00:00 - put(10, 25, 5000)
       * 12:00:04 - get(10) -> 25
       * 12:00:06 - get(10) -> null
       */
      //map has to null the key after the timeout

      (function(){
        let obj = {};
        let handle;
        function put(key, val, timeout) {
          obj[key] = val;
          if (handle && Object.hasOwnProperty(key)) {
            clearTimeout(handle);
          }
          handle = setTimeout(function(){
            obj[key] = null;
          }, timeout);
        }
        function get(key) {
          return obj[key];
        }

        put(10, 25, 3000); //after 3 sec, obj[10] should return null
        console.log(get(10));
        setTimeout(() => {
          console.log('--',get(10));
        }, 2000); //try timeout as 4000, you get null
      })();


      (function(){
        let obj = {}; // key value pairs key, val - {val:val, timeout:timeout, currentTimeStamp}
        function put(key, val, timeout) {
          obj[key] = { val, timeout, currentTimeStamp: new Date().getTime() };
          // { 12: {val: 13, timeout: 7000, currentTimeStamp: 4234 } }

        }
        function get(key) {
          const timeNow = new Date().getTime();
          const timeDiff = timeNow - obj[key].currentTimeStamp; //timeDiff in millisec
          if (timeDiff >= obj[key].timeout) {
            obj[key].val = null;
          }
          return obj[key].val;
        }
        put(10, 25, 3000);
        console.log(get(10));
        setTimeout(() => {
          console.log(get(10));
        }, 4000);
      })();
      //why you choose one vs. other (setTimeout vs w/o using it) - use 2 (https://medium.com/front-end-hacking/javascript-event-loop-explained-4cd26af121d4)
      //in the first case, after handle = setTimeout(function(){..} say you have a blocking statement (like an intensive operation - a loop with 10 million iterations)
      //it's going to execute first and only after it finishes setTimeout callback will be executed. By that time, it might be a time well past the timer timeout.
      //so you can't expect precise results here.
      //Point to note is, once you hit asynchronous method setTimeout, browser web API takes over and callback will be added to the message queue after the timeout.
      //messages/items in the message queue gets added to the call stack for execution, only if call stack is empty.

/*
      const colors = ["aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet",
      "brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan",
      "darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon",
      "darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue",
      "firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink",
      "indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow",
      "lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue",
      "lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen",
      "mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy",
      "oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff",
      "peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver",
      "skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white",
      "whitesmoke","yellow","yellowgreen"]

      function findColor(str) {
        const result = [];
        for (const color of colors) {
          if (hasString(color, str)) {
            result.push(color);
          }
        }
        return result;
      }
      //returns true if str is part of word
      function hasString(word, str) { //word: darkturquoise, str = 'uqi'
        const chars = str.split(''); // ['u', 'q', 'i'];
        let prevIndex = -1;
        let currIndex = -1;
        for (let char of chars) {
          currIndex = word.indexOf(char, prevIndex);
          if (currIndex === -1 || currIndex < prevIndex) {
            return false;
          }
          prevIndex = currIndex;
        }
        return true;
      }


      console.log(findColor('uqi')); // u q i should appear in sequence in the string, can be other characters in between
      // [ 'darkturquoise', 'mediumaquamarine', 'mediumturquoise', 'paleturquoise', 'turquoise' ]

      console.log(findColor('zre'))
      // [ 'azure' ]

      console.log(findColor('gold'))
      // [ 'darkgoldenrod', 'gold', 'goldenrod', 'lightgoldenrodyellow', 'palegoldenrod' ]
**/

 /*

    accordion - do it only with CSS (keep content of accordian tab within it and you can add class in JS to set as active)
    hack - radio button or checkbox (checked property)

    web sockets - real time communication - no lag like ajax

    Edge case handling:
    when you implement a method, take care of various test edge cases -
    ex: function getWorkRate(workers, rates) {
      return workers.length/rates/length;
    }
    //what if workers [] is empty or null etc...

    Good idea to attach event listener to parent and get hold of clicked element by event.target (event bubbling) instead of attaching event listeners
    to all children (it will burden the DOM and it gets heavy) -- say to display contact cards
    In accordion, if you do the same - say accordion tab has (icon, text) left aligned and upward/downward arrow to the right, what if you click on
    icon or arrow, then even.target is that, but you have event listener to the parent of all tabs, then how you can change the color of clicked tab with
    event.target being an element with in the clicked tab??
 */
 // System design intv questions - https://www.quora.com/How-do-you-answer-the-interview-question-How-would-you-design-and-scale-a-platform-like-Twitter
 // Grokking the System Design Interview - https://www.educative.io/collection/5668639101419520/5649050225344512

 // Parallelism - https://davidwalsh.name/async-await
 // https://developers.google.com/web/fundamentals/primers/async-functions (refer Careful! Avoid going too sequential)

 /*
 async function series() {
  await wait(500); // Wait 500ms…
  await wait(500); // …then wait another 500ms.
  return "done!";
 }
 async function parallel() {
  const wait1 = wait(500); // Start a 500ms timer asynchronously…
  const wait2 = wait(500); // …meaning this timer happens in parallel.
  await wait1; // Wait 500ms for the first timer…
  await wait2; // …by which time this timer has already finished.
  return "done!";
 }
*/
    </script>
  </head>
  <body>

  </body>
</html>
