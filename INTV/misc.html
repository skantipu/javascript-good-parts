<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
  /*
   Return the sum of all integers from a random String. Continuous Integers must be considered as one number.
   If the input String does not have any Integers, return 0.
   You may ignore decimals, float, and other non-integer numbers
   @param str : Input String
   Given the following inputs, we expect the corresponding output:
   "1a2b3c" => 6        (1+2+3)
   "123ab!45c" => 168   (123+45)
   "abcdef" => 0        (no Integers in String)
   "0123.4" => 127      (0123+4)
   "dFD$#23+++12@#T1234;/.,10"  => 1279  (23+12+1234+10)
   */
  (function(){
    const input = "dFD$#23+++12@#T1234;/.,10";
    const arr = input.match(/\d+/g) || new Array();  // note that the + is important in regex, even /\d{1,}/gi/ will work. If /\d/g or /[0-9]/g is used, matching set would be [1,2,3,4,0]
    const res = arr.reduce((sum, val)=>parseInt(sum)+parseInt(val),0);
    console.log(res);
  })();

  //-----------------------------------------------------------
  //Longest palindrome substring - DP related
  //GeeksforGeeks - classic DP problems, others - leetcode
  //-----------------------------------------------------------

  /*
   // package whatever; // don't place package name!
   // Move Zeros to End of Array
   // Given an array of random numbers, Push all the zeroâ€™s of a given array to the end of the array.
   // For example, if the given arrays is:
   // {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0}
   // It should be changed to
   // {1, 9, 8, 4, 2, 7, 6, 0, 0, 0, 0}
   // The order of all other elements should remain the same.
   */

  // input: [23, 3, 22, 13, 5, -9, 0], output: return index of 22 -> 2. For that, you need to sort the array and then do binary search

  // best data structure to store a table with rows and columns, spreadsheet program, insert a column, row etc. --> 2d array, doubly linked list etc.

  //input = [1,2,3,4], output = [(2*3*4), (1*3*4), (1*2*4), (1*2*3)]

  (function() {
    var ip = [1,2,3,4];
    var res = ip.map((elem, index) => {
      return ip.reduce((acc, elem, ind) => {
        if(index !== ind)
          return acc * elem;
        return acc;
      }, 1);
    });
  })();

  // missing words in subsequence - https://gist.github.com/mmloveaa/af6ac0a1fd28249abf63

  // chess game in react js


//   import java.util.List;
//
//   public interface Apis {
//
//   /*
//   * Creates a new user and store it.
//   * All User attributes are required.
//   * Cannot create new user if a user with same username already exists.
//   * Needs to run in O(1)
//   */
//  void createUser(User user) throws Exception;
//
//  /*
//   * Find user by its username (shoule run in O(1))
//   */
//  User findUser(String username);
//
//  // search for users by search criteria (can be by the username, email, firstname or lastname)
//  // Can run in O(n)
//  List<User> searchUsers(String searchCriteria);
//
//  // deletes user from the store
//  // Needs to run in O(1)
//  void deleteUser(String username);
//
//  }

  //-----------------------------------------------
  //  Paypal question
  (function() {
    var x ={
      "home_address":{
        "street_name":"test",
        "apartment_number":33
      },
      "contact_no":{
        "home_number":123,
        "work":{
          "mobile_number":234,
          "fax_number":34243
        }
      }
    };
    /*
    output:
      var x ={
        "homeAddress":{
          "streetName":"test",
          "apartmentNumber":33
        },
        "contactNo":{
          "homeNumber":123,
          "work":{
            "mobileNumber":234,
            "faxNUmber":34243
          }
        }
      };
    */

    //method to convert from 'contact_no' to 'contactNo'
    function formatKey(key) {
      const words = key.split("_");
      const newWords = words.map((word, i) => {
        if (i > 0) {
          return `${word.charAt(0).toUpperCase()}${word.substring(1)}`;
        }
        return word;
      });
      return newWords.join("");
    }
    /*
    // alternate way
    function formatKey(key) {
      return str.replace(/_([a-z])/g, function(str) {
        return str[1].toUpperCase();
      })
    }
    */
    function parseObj(obj) {
      const res = {};
      for (const key in obj) {
        const formattedKey = formatKey(key);
        res[formattedKey] = typeof obj[key] === 'object' ? parseObj(obj[key]) : obj[key];
      }
      return res;
    }

    console.log(parseObj(x));

  })();

  //-----------------------------------------------

  (function() {

    function myFun(fn, delay) {
      var ctr = 0;
      return function() {
        setTimeout(function() {
          fn(ctr, delay);
        }, ctr * delay);
        ctr++;
      }
    }

    function callBack(x,y) {
      console.log('Hi', x, y, x*y);
    }

    var x = myFun(callBack, 1000);
    x(); // to be called after 1 sec
   // x(); to be called after 2 sec
   // x(); to be called after 3 sec
   //...
    // enter x() one after other in the console.
  })();

  // -------------------------------------------
  (function(){
    var items =
      [{
        "type": "iphone",
        "color": "silver"
      }, {
        "type": "tv",
        "color": "grey"
      },{
        "type": "radio",
        "color": "black"
      }];

    var exclude =
      [{
        "key": "color",
        "val": "silver"
      }, {
        "key": "type",
        "val": "radio"
      }];

    /*
     output: [
       {
       "type": "tv",
       "color": "grey"
       }
     ]
     */
    // below solution can be improved - it's a working one
    // you can safely assume that in exclude array, key values will be one of type/color

    //returns {color: silver, type: radio}
    function getExcludeObj(exclArr) {
      return exclArr.reduce((acc, elem) => {
        acc[elem.key] = elem.val;
        return acc;
      }, {});
    }

    function checkObjMatch(obj1, obj2) {
      let match = false;
      for(let key in obj1) {
        if (key in obj2 && obj2[key] === obj1[key]) {
          match = true;
        }
      }
      return match;
    }

    function computeRes(items, excludeArr) {
      const res = [];
      const helperObj = getExcludeObj(excludeArr);
      items.forEach((elem) => {
        if (!checkObjMatch(helperObj, elem)) {
          res.push(elem);
        }
      });
      return res;
    }

    console.log(computeRes(items, exclude));
  })();

  // -------------------------------------------

  (function() {
    var items =
      [{
        "type": "iphone",
        "color": "silver"
      }, {
        "type": "tv",
        "color": "grey"
      },{
        "type": "radio",
        "color": "black"
      }];

    var exclude =
      [{
        "key": "color",
        "val": "silver"
      }, {
        "key": "type",
        "val": "radio"
      }, {
        "key": "color",
        "val": "blue"
      }];

    /*
     output: [
     {
     "type": "tv",
     "color": "grey"
     }
     ]
     */
    // given key values (color and type) in the exclude array will only be one of items keys.

    /*
     have a map as below:

     {
     color: [silver, blue],
     type: [radio]
     }


     Remember
     push() returns length of array
     reduce() takes accumulator, element as parameters, mind the order
     reduce() has to return accumulator
     forEach(), if you wanna continue iteration, you can just 'return'; ('continue' does not work)
     */
    (function(items, exclude) {
      const result = [];
      const excludeMap = exclude.reduce((acc, elem) => {
          acc[elem.key] ? acc[elem.key].push(elem.val) : acc[elem.key] = [elem.val];
      return acc;
    }, {});
      items.forEach(elem => {
        if (excludeMap.type.indexOf(elem.type) == -1 && excludeMap.color.indexOf(elem.color) == -1) {
        result.push(elem);
      }
    });
      console.log(result);
    })(items, exclude);
  })();

  // -------------------------------------------

  (function () {
    //input: thereisaboynamedsachinandheisstudying, hcinas
    //output: thereisaboynamedandheisstudying  (after removing hcinas anagrams from the sentence)

    var longStr = 'thereisaboynamedschainheisstudying', anagram = 'hcinas';
    // may be you can try binary search algo too
    function isAnagram(wordA, wordB) {
      if (wordA === wordB) {
        return true;
      } else if (wordA.length !== wordB.length) {
        return false;
      }
      const map = {};
      for (let letter of wordA) {
        if (letter in  map) {
          map[letter]++;
        } else {
          map[letter] = 1;
        }
      }

      for (let letter of wordB) {
        if (letter in map) {
          map[letter]--;
          if(map[letter] === 0) {
            delete map[letter];
          }
        } else {
          map[letter] = 1;
        }
      }

      return Object.keys(map).length === 0;
    }

    function findAnagramSubStr(str, anagram) {
      const anaLen = anagram.length;
      for (let i = 0; i < str.length-anaLen; i++) {
        let substr = str.substring(i, anaLen+i);
        if (isAnagram(substr, anagram)) {
          return str.replace(substr, '');
        }
      }
      return str;
    }

    console.log(findAnagramSubStr(longStr, anagram));
  })();

  //----------------------------------------------------------
  //Binary Search

  (function(){
    const arr = [2, 3, 9, 12, 44, 233, 999];
    const elm = 32;
    function binarySearch(first, last) {
      if (last - first <= 1) {
        return elm === arr[first] || elm === arr[last];
      }
      const middle = Math.ceil((first + last)/2);
      if (arr[middle] === elm) {
        return true;
      } else if (arr[middle] > elm) {
        return binarySearch(first, middle);
      } else {
        return binarySearch(middle, last);
      }
    }
    if (binarySearch(0, arr.length - 1)) {
      console.log('found');
    } else {
      console.log('not found');
    }
  })();

  //----------------------------------------------------------
  // Objective: to find sum of negative numbers in a matrix.

  (function(){
    // Returns index of right most negative number in the array. Assumes array is sorted asc. If no negative number present, returns -1
    function search(arr) {
      function binarySearch(left, right) {
        if (right - left <= 1) {
          if (arr[right] < 0) {  // important to have right condition check first, followed by left
            return right;
          } else if (arr[left] < 0) {
            return left;
          }
          return -1;
        }
        const middle = Math.ceil((left + right)/2);
        if (arr[middle] < 0) {
          return binarySearch(middle, right);
        } else {
          return binarySearch(left, middle);
        }
      }
      return binarySearch(0, arr.length - 1);
    }

    function countNegativeNums(matrix) {
      let sum = 0;
      for (arr of matrix) {
        let index = search(arr);
        if (index !== -1) {
          sum += (++index);
        }
      }
      return sum;
    }
    // matrix can be represented as array of arrays.
    console.log(countNegativeNums([[-3, -2, -1, 0, 3], [-12, 1, 2, 5, 10], [0, 1, 4, 5, 34], [-5, -4, -3, -2, -1]])); //9
  })();


  // Find 5 most repeating words in the string
  (function() {
    const sentence = 'Downtown Greensborough is a major financial center in which many citizens either drive or rely on public transportation to get to work. This setup has led up to a spate in the number of pedestrians who have been struck and killed by vehicles. In an effort to curb the number of pedestrian-related fatalities, Greensborough has installed speed reduction signs at the six city intersections at which the highest numbers of fatalities have occurred in the last year. The Greensborough city government predicts that the number of traffic fatalities will significantly decrease once the speed reduction signs have been installed.'
    const parsedSentence = sentence.replace(/[^a-z ]/gi, '');
    const words = parsedSentence.split(" ");
    const map = {};
    for (let word of words) {
      if (map.hasOwnProperty(word)) {
        map[word]++;
      } else {
        map[word] = 1;
      }
    }
    console.log(map);
    const freqArr = [];
    for (let word in map) {
      const wordList = freqArr[map[word]] || [];
      wordList.push(word);
      freqArr[map[word]] = wordList;
    }
    console.log(freqArr);
    const result = computeRes(freqArr, 5);
    function computeRes(arr, len) {
      const res = [];
      for (let i = arr.length - 1; i >= 0; i--) {
        if (arr[i] && arr[i].length > 0) {
          for (let word of arr[i]) {
            res.push(word);
            if (res.length >= len) {
              return res;
            }
          }
        }
      }
      return res;
    }
    console.log(result)

  })();
</script>
</body>
</html>